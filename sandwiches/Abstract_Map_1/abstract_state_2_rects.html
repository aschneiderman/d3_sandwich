<DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Abstract State Map: Basic Recipe</title>
  <script src="http://d3js.org/d3.v3.min.js"></script>        <!-- d3 library -->
  <link href="../../sandwich.css" rel="stylesheet" media="screen">      <!-- sandwich's CSS -->
  <script src="abstract_state.js"></script>
</head>
<body>
  <div id="container">

    <div id="sandwich-heading">
      <h1> <img src="../../sandwich_icon.jpeg"  height="50" width="50">  d3 sandwich </h1>
      <div id="sandwich-border"></div>
    </div>

      <h2> Abstract State Map</h2>
      <h2>   Step #2: Create a Rectangle for Each State </h2>

      <p>In Step 1, we created an <b>array</b> of <b>objects</b>, one per state, containing the info needed to put each state on the map. In Step 2, the code below uses that info to create each state's rectangle.</p>

<div class="recipe_row">
<div class="recipe_text">

  <p> Does the code to create the rectangles look weird? Yes, it does.</p>

  <p>But don't sweat it! This code is a pattern you're going to use over and over in your D3 recipes. After you've used it a couple of times, it'll become second nature.</p>

  <p> So for today, all you need is a rough idea of how the code works.</p>

  <p> Before we dive in, let's spend a little time playing with the code; make a few changes and see how they affect the map.</p>

</div>
<div class="recipe_code">
  <pre class="code_play">
    var width = <i id="width">40</i>, height = <i id="height">40</i>, cellsize = <i id= "cellsize">39</i>;
    svg_area = d3.select("svg")

    // Insert a rectangle for each state
    svg_area.selectAll("rect")
        .data(state_map)
      .enter()
      .append("rect")
        .attr("x", function(d,i)  { return d.col * width;})
        .attr("y", function(d,i) {return d.row * height;})
        .attr("width", cellsize)
        .attr("height", cellsize)
        .style("fill", "<i id="fill">DarkRed</i>");
  </pre>
</div>
</div>  <!-- end recipe_row -->

<div class="recipe_row">
<div class="recipe_text">
  <svg width="520" height="400" class="code_play" class="code_play" class="SVG_playground"></svg>        <!-- SVG graphics will go here  -->

  <script type="text/javascript">
    svgName = 'svg.code_play';

    console.log("SVG map we are going to use:" + svgName);
    make_rectangles(svgName, get_states(), [], 0, 0);
  </script>

</div>
<div class="recipe_code">
  <form class="code_play">
    <table class="input_table">
      <tr><td>Width</td><td><input name="width" type="text" value="40"> </td></tr>
      <tr><td>Height</td><td><input name="height" type="text" value="40"> </td></tr>
      <tr><td>Cell Size</td><td><input name="cellsize" type="text" value="39"> </td></tr>
      <tr><td>Fill</td><td><input name="fill" type="text" value="DarkRed"> </td></tr>
      <tr><td></td><td><input type="button" value="Update the Map"  onClick="updateValue('code_play', this)"> </td></tr>
    </table>
  </form>
</div>
</div>  <!-- end recipe_row -->
<script type="text/javascript">

  // Captains log:
  //  So what I've learned:
  //    In Firefox, on Change works just fine for Step 1 and, on my local drive, for Step 2, but not on GitHub Step 2
  //  It Internet Explorer, on change works just fine for Step 1 but not at all for Step 2
  //
  // So for step 2, I need to switch to using an update button
  // I also need to document this _in the code_ as well as somewhere else, so I won't bang my head against this will again
  //
  //
  // Break the state map code up so that creating the text is done separately,
  //  so I can just create the rectangles while still having the code to create the whole map
  //
  // Rewrite changeValue so that you pass it an anonymous function that has the code you need to use

  var state_rects =  d3.select(svgName)
      .selectAll("rect");

  var values = {width: 40, height: 40, cellsize: 39, fill: "Sienna"};
  // Better yet, I could grab one rectangle and get these values from it, I think  :-)

  function updateCodeValue(formID, valueID, newValue) {
    // Updates the value of a line of code and highlights the line
    fullID = 'pre.' + formID  + " #" + valueID;
    console.log('fullID:' + fullID);
    d3.select(fullID)
      .text(newValue)
      .style("background-color", '#FFFF66');
  };
  //
  // function changeValue(attribute, input) {
  //   updateCodeValue('code_play_form', attribute, input.value);
  //   // state_rects.attr(attribute, input.value);
  //   values[attribute] = input.value;
  //   state_rects
  //     .attr("x", function(d,i)  { return d.col * values['width'];})
  //     .attr("y", function(d,i) {return d.row * values['height'];})
  //     .attr("width", values['cellsize'])
  //     .attr("height", values['cellsize'])
  //     .style("fill",  values['fill']);
  //     // .style("fill",  "Red");
  // };

  function updateValue(playName, input)  {

      // Load the form values into the "values" object
      var playForm = "form." + playName;
      var values = {};
      // var formValues =  d3.select(playForm)
      //     .selectAll("input")[0]    //  comes back as an array within an array, so drop the outer array
      //     .slice(0,-1);     // drop the button that's at the end of the form;  switch to using a filter?
      // formValues.forEach(function(d, i) { console.log(d.name + " " + i); values[d.name] = d.value; });
      // console.log("Color is: " + values.fill);
      d3.select(playForm)
          .selectAll("input")[0]    //  comes back as an array within an array, so drop the outer array
          .slice(0,-1)     // drop the button that's at the end of the form;  switch to using a filter?
          .forEach(function(d, i) {
              values[d.name] = d.value;
              updateCodeValue(playName, d.name, d.value);
          });
      console.log("fill is: " + values.fill);

      state_rects
        .attr("x", function(d,i)  { return d.col * values.width;})
        .attr("y", function(d,i) {return d.row * values.height;})
        .attr("width", values.cellsize)
        .attr("height", values.cellsize)
        .style("fill",  values.fill);
        // .style("fill",  "Red");

  };


  //
  //
  //
  // function changeRecipeFill(input)  {
  //   updateCodeValue('fillLine', 'fill', input.value);
  // };


</script>
<p>FYI, if you play around with the height, width, and cellsize, you'll discover something interesting.
  The map looks like we draw white borders between the state rectangles, but it turns out we don't.
 If cellsize is smaller than height and width,
that creates some whitespace between the rectangles that looks like a border.
 If you haven't played with it already, give it a try.</p>





<h3>The Revenge of Your High School Math Teacher, Part 1</h3>
<p> In high school, your math teacher probably made you learn geometry:  rectangles, circles, etc. You probably wondered, why am I ever going to need any of this? Now you know: to create cool data visualizations in D3!</p>

<p> The good news: the math you're going to need is really simple.</p>

<p> The first thing we need to know: what info do we need to create a rectangle?</p>
<ul><li> Height</li>
<li> Width </li>
<li> Color, which in D3 is called "Fill" </li>
<li> X and Y coordinates where the rectangle should start</li></ul>
To get a feel for it, let's play:
<div class="recipe_row">
<div class="recipe_text">
  <svg width="500" height="160"  class="rectangle">
  <rect x="50" y="20" width="40" height="40"
   style="fill:DarkRed" />
  </svg>        <!-- SVG graphics will go here  -->
</div>
<div class="recipe_code">
  <form class="rectangle">
    <table class="input_table">
      <tr><td>Width</td><td><input name="width" type="text" value="40"> </td></tr>
      <tr><td>Height</td><td><input name="height" type="text" value="40"> </td></tr>
      <tr><td>Fill</td><td><input name="fill" type="text" value="DarkRed"> </td></tr>
      <tr><td>X</td><td><input name="X" type="text" value="50"> </td></tr>
      <tr><td>Y</td><td><input name="Y" type="text" value="20"> </td></tr>
      <tr><td></td><td><input type="button" value="Update It!"  onClick="updateRectangle('rectangle', this)"> </td></tr>
    </table>
  </form>
</div>
</div>  <!-- end recipe_row -->



  <script type="text/javascript">
    svgName = 'svg.rectangle';
    console.log("SVG map we are going to use:" + svgName);


    var rectangle =  d3.select(svgName).select("rect");
  </script>

<script type="text/javascript">


// Need to redo updateValue so it gets passed the anonymous function containing the update



function updateRectangle(playName, input)  {
    var playForm = "form." + playName;
    var values = {};
    d3.select(playForm)
        .selectAll("input")[0]    //  comes back as an array within an array, so drop the outer array
        .slice(0,-1)     // drop the button that's at the end of the form;  switch to using a filter?
        .forEach(function(d, i) {
            values[d.name] = d.value;
        });
    console.log("fill is: " + values.fill);

    rectangle
      .attr("x", values.X)
      .attr("y", values.Y)
      .attr("width", values.width)
      .attr("height", values.height)
      .style("fill",  values.fill);
};
</script>

<p>Try changing the rectangle's height, width, X, Y, and fill/color and see what happens.</p>


<h3>Revenge of Your High School Math Teacher, Part 2</h3>


<p>We've learned how to create a rectangle. Now we need to use math to do 2 more things:</p>
<ol><li> Put a bunch of rectangles on the page, each with its own starting point (i.e., X and Y)</li>
<li> Create some space between each of the rectangles, which makes it looks like there is a white border between the rectangles</li></ol>


{ Using the variables height, width, and cell size is confusing. What we need to do is something like rectangleSize and something else. What are the best names for these? And then how is the best graphic way to give someone a feel for how the math works?}

<hr/>



<i>
  <h6>Notes Dump</h6>


<p> <b>Before you start playing with the rectangles </b>, take a look at X and Y. Notice how each X and Y is 40 more than the last one? That's because each rectangle's height and width is 40.
<p>
<div class="recipe_row">
<div class="recipe_text">
  <svg width="500" height="160" id="" class="SVG_playground"></svg>        <!-- SVG graphics will go here  -->
</div>
<div class="recipe_code">
  <form>
    <table class="input_table">
      <tr><td>
        State
      </td><td>
        X
      </td><td>
        Y
      </td>
      </tr>
      <tr>
        <td>ME</td>
        <td ><input type="text" class="state_input" value="0"  onChange="updateRow('ME', this)"></td>
        <td><input type="text" class="state_input" id='ME_col' value="10" onChange="updateCol('ME', this)"></td>
      </tr>
      <tr>
        <td>VT</td>
        <td><input type="text" class="state_input" value="1"  onChange="updateRow('VT', this)"></td>
        <td><input type="text" class="state_input" value="9"  onChange="updateCol('VT', this)"></td>
      </tr>
      <tr>
        <td>NH</td>
        <td><input type="text" class="state_input" value="1"  onChange="updateRow('NH', this)"></td>
        <td><input type="text" class="state_input" value="10" onChange="updateCol('NH', this)"></td>
      </tr>
      <tr>
        <td>WA</td>
        <td><input type="text" class="state_input" value="2"  onChange="updateRow('WA', this)"></td>
        <td><input type="text" class="state_input" value="0" onChange="updateCol('WA', this)"></td>
      </tr>
      <tr>
        <td>ID</td>
        <td><input type="text" class="state_input" value="2"  onChange="updateRow('ID', this)"></td>
        <td><input type="text" class="state_input" value="1" onChange="updateCol('ID', this)"></td>
      </tr>
      <tr>
        <td>NY</td>
        <td><input type="text" class="state_input" value="2"  onChange="updateRow('NY', this)"></td>
        <td><input type="text" class="state_input" value="8" onChange="updateCol('NY', this)"></td>
      </tr>
    </table>
  </form>
</div>
</div>
</div>  <!-- end recipe_row -->
<script type="text/javascript">

</script>

<p> Now that we know that to translate a state's row into X, we want to multiply the row by 40 and we want to do the same math for Y, how do we tell the computer? In math class, they use what they call a formula:</p>

<ul><li> X = X * width</li>
<li>Y = Y * height</li></ul>

</i>
<hr/>

<h3>The Select-Enter-Append Pattern</h3>


<p> How do we do this in D3?</p>

<p> This is where the idea of the grid we talked about in Step 1 comes in. We've got 3 pieces of data about each state:</p>
<ul><li> The state's <b>name</b> (e.g., "WA")</li>
<li> The state's <b>row</b> on the grid (e.g., 2)</li>
<li> the state's <b>column</b> on the grid (e.g., 0)</li></ul>
<p> So what we need to tell the computer is how to translate row and column into X and Y.</p>

<div class="recipe_row">
<div class="recipe_text">
<p>svg tells the computer to create an area 960 pixels wide and 400 pixels tall where we will put the rectangles.</p>
</div>
<div class="recipe_code">
  <pre>
&ltsvg width="960" height="400"&gt&lt/svg&gt        &lt!-- SVG graphics will go here  --&gt
  </pre>
</div>
</div>  <!-- end recipe_row -->

<div class="recipe_row">
<div class="recipe_text">
<p>Next we tell the computer to create a variable called svgArea that points to the SVG area we just created.</p>
</div>
<div class="recipe_code">
  <pre>
    svg_area = d3.select("svg")
  </pre>
</div>
</div>  <!-- end recipe_row -->



<p>Here's the code that tells the computer to use the data in stateMap to create the rectangles.  In most tutorials, here's how they explain what this code is doing:</p>
<div class="recipe_row">
<div class="recipe_text">
  <ul><li>Select every rectangle that's in the SVG area.</li>
  <li>Bind the data in stateMap to those rectangles.</li>
  <li>If there aren't enough rectangles for all the data,
  create a new rectangle for the remaining data.</li></ul>
</div>
<div class="recipe_code">
  <pre>
    svg_area.selectAll("rect")
        .data(state_map)
      .enter()
      .append("rect")
  </pre>
</div>
</div>  <!-- end recipe_row -->

<p>If you're feeling confused, that's because you're paying attention.</p>

<p> There are some key key technical reasons why the man who created D3 decided to do it this way. Bottom line: you could care less. All you need to know is:
<ul><li> Yeah, it's weird</li>
<li> You are going to use this pattern in just about every recipe you use, so don't sweat it</li></ul>






<p> Each rectangle is going to have the same width, height, and fill/color, so we can just tell the computer the value to use.</p>

<p> ( A side note: You might have noticed that for width and height we use "attr", which is short for attribute, but for fill/color, we use "style."  Why aren't they all "attr"? There is a geeky answer, but you really need to know right now? No, you don't. All you need to know: sometimes you use "attr," sometimes you use "style", just copy which ever one is used in the example or documentation you are reading and will be fine.) </p>


<p> What's this weird "function(d,i)" business?  As D3 loops through each of the items in stateMap, it creates two variables to help you:
<ul><li>d:  the item you are on – e.g., WA</li>
<li>i: the number of the item you're on -- 0, 1, 2, 3 (computers like to start counting from 0)</li></ul>
<p> In this case we only care about d, the item.  We can use d to get to the info we have about each state: "d.col" is the state's column.</p>
<p> The bad news: this looks weird. The good news: you are going to see this pattern over and over and over in every D3 visualization you write. So instead of worrying about the individual details right now, here's how to read the code:
<div class="recipe_row">
<div class="recipe_text">
<p> For each rectangle: </p>
<ul><li>Set X to the state's col * width</li>
<li>Set Y to the state's row * height</li></ul>
</div>
<div class="recipe_code">
  <pre>
.attr("x", function(d,i)  { return d.col * width;})
.attr("y", function(d,i) {return d.row * height;})
  </pre>
</div>
</div>  <!-- end recipe_row -->
<p> (A side note: in case you're wondering "what's that business about function" or if you have done some programming before and you're wondering what is a function doing inside a line of code, it's called an anonymous function – we'll explain more in the coming months, but for now don't worry about it).</p>




<p> After you've worked on a couple of D3 graphs, you won't see those individual lines – you'll see a pattern. Here's how you'll read the code:</p>
<div class="recipe_row">
<div class="recipe_text">
  <p>If the code says <b>.enter and .append("rect")</b>:<br/>
  Inside the SVG area, create a rectangle for every item in stateMap.</p>
</div>
<div class="recipe_code">
  <pre>
    svg_area.selectAll("rect")
        .data(state_map)
      .enter()
      .append("rect")
  </pre>
</div>
</div>  <!-- end recipe_row -->


<p>You're going to use this pattern over and over and over – almost every D3 graph uses it. In fact, you'll see it again in Step 3.</p>

<p>Eventually – a few months from now? a year from now? – those individual lines of code will make more sense. But for now, it's not worth worrying about.</p>




<h3>Recap: D3's "Saute until the Onions Start to Brown </h3>
<p> Ouch! That was way too many things to have to learn when you're just getting started. We're sorry about that. Like we said at the beginning of this Step, it's what makes the first few baby steps of D3 so rocky.</p>

<p> The good news is, at this point you don't need to completely understand the details.</p>

<p> The most important thing you need to know: you're going to see these patterns over and over and over. So if at the beginning you're not entirely comfortable with each individual line, don't sweat it.  When you see a chunk of code that looks like this, here's how you read it:</p>

<div class="recipe_row">
<div class="recipe_text">
<p> For each item in stateMap, create a rectangle:</p>
<ul><li> x = the state's column * width</li>
<li> y = the state's row * height</li>
<li> width = cellsize</li>
<li> height = cellsize</li>
<li>fill, aka color = DarkRed</li></ul>
</div>
<div class="recipe_code">
  <pre>
    var width = <i id="width">40</i>, height = <i id="height">40</i>, cellsize = <i id= "cellsize">39</i>;
    svg_area = d3.select("svg")

    // Insert a rectangle for each state
    svg_area.selectAll("rect")
        .data(state_map)
      .enter()
      .append("rect")
        .attr("x", function(d,i)  { return d.col * width;})
        .attr("y", function(d,i) {return d.row * height;})
        .attr("width", cellsize)
        .attr("height", cellsize)
        .style("fill", "<i id="fill">DarkRed</i>");
  </pre>
</div>
</div>  <!-- end recipe_row -->

<p> So yeah, initially it looks pretty weird. But if you know how to read the pattern, you've got an amazing amount done in just a few lines of code. </p>

<p>And after you've done a couple D3 visualizations, it'll become as natural  to you as the instructions "sauté the onions until they start to brown" are to an experienced cook.</p>







        <div id= "sandwich_footer">
        </div>
      </div>
    </body>
    </html>
